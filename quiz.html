#<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Quiz</title><script>shim=`
default_question_list="""`; default_question_list = `
integrand:integral
Int u*dv:u*v-Int v du
#x^n (n!=1):(x^(n+1))/(n+1)+C
1/x:Log[Abs[x]]+C
E^x:E^x+C
a^x:(a^x)/Log[a]+C
Sin[x]:-Cos[x]+C
Cos[x]:Sin[x]+C
(Sec[x])^2:Tan[x]+C
(Csc[x])^2:-Cot[x]+C
(Sec[x])*(Tan[x]):Sec[x]+C
(Csc[x])*(Cot[x]):-Csc[x]+C
#Tan[x]:Log[Abs[Sec[x]]]+C
#Cot[x]:Log[Abs[Sin[x]]]+C
#Sec[x]:Log[Abs[Sec[x]+Tan[x]]]+C
#Csc[x]:Log[Abs[Csc[x]-Cot[x]]]+C
{G{eorge} }Washington:1789-{17}97
{J{ohn} }Adams:1797-1801
{T{homas} }Jefferson:1801-{{18}0}9
{J{ames} }Madison:1809-{18}17
#(a^2-x^2)^(-1/2):ArcSin[x/a]+C
(a^2+x^2)^(-1):(1/a)*ArcTan[x/a]+C
#(x*Sqrt[x^2-a^2])^(-1):(1/a)*ArcSec[x/a]+C
#(a^2-x^2)^(-1):(1/(2*a))*Log[Abs[(x+a)/(x-a)]]+C
#(x^2-a^2)^(-1):(1/(2*a))*Log[Abs[(x-a)/(x+a)]]+C
`; python_code = `"""

import sys
import time
import argparse
quiz = {}

DEFAULT_INDEX_FILE='./index'
BSDQUIZ_DATA_DIRECTORY='/usr/share/games/bsdgames/quiz'
BSDQUIZ_INDEX_FILE=BSDQUIZ_DATA_DIRECTORY+'/index'

def customize_cmdline_parser(p):
  p.add_argument('-t', '--tutorial', \
    action='store_true', help='Use tutorial mode')
  p.add_argument('-d', '--default', \
    action='store_true', help='Use default question set')
  p.add_argument('-i', '--index_file', \
    nargs='?', type=argparse.FileType('r'), default=None)
  p.add_argument('question', nargs='?')
  p.add_argument('answer', nargs='?')

def adapt_regexp(t):
  return(t)  

cmdline_parser = argparse.ArgumentParser()
customize_cmdline_parser(cmdline_parser)

cmdline_args=cmdline_parser.parse_args()

if cmdline_args.tutorial:
  print('tutorial mode was activated')

index_blob=''
if cmdline_args.index_file:
  print('an index file was specified: ' + cmdline_args.index_file.name)
  with open(cmdline_args.index_file.name) as f:
    index_blob=f.read()
else:
  for i in [DEFAULT_INDEX_FILE, BSDQUIZ_INDEX_FILE]:
    try:
      print('about to try: ' + i)
      with open(i) as f:
        index_blob=f.read()
    except IOError:
      print(i + ' cannot be read')
    if index_blob != '':
      break

if index_blob == '':
  print('no index information found, bailing out')
  sys.exit(1)

if cmdline_args.question and cmdline_args.answer:
  print('everything is ok')
  print(cmdline_args.question)
  print(cmdline_args.answer)
elif cmdline_args.question and not cmdline_args.answer:
  parser.print_help()
else:
  print('we will now show the possible categories')
  print(index_blob)

if cmdline_args.default:
  print('using embedded default_question_list')
  for line in default_question_list.splitlines():
    clean = line.strip()
    filt = clean.replace('\\','')
    if ':' in filt:
      q,a = filt.split(":")
      quiz[q] = a;
  words = quiz.keys()
  for w in words:
    print(w + '?')
    start = time.time()
    s = input('')
    elapsed = (time.time() - start)
    if s == quiz[w]:
      print('Right answer in '+str(round(elapsed,2))+' seconds \n')
    elif s == "":
      print(quiz[w])
    else:
      print('given answer was ' + s + ' correct answer is ' + quiz[w])

javascript_css_html_code_="""`

    function say(text){
        //document.write(text + " <br /> ");
        console.log(text);
    }

    function keyToIndex(map,key) {
        var i = 0; for (var k of map.keys()) { if (k === key) return i; i++ }
        return null;  // if the key is not found
    }

    function adaptRegexp(regexp) {
        return regexp.replace(/\{/g,'(').replace(/\}/g,')?');
    }

    class QuestionCloud {
        constructor(questionId, factMap) {
            this.questionId = questionId;
            this.factMap = factMap;
        }

        getUniquifier(prompt, target) {
            var u = this.questionId;
            u += ":" + (keyToIndex(this.factMap,prompt) + 1);
            u += "/" + this.factMap.size;
            u += ":" + (keyToIndex(this.factMap,target) + 1);
            u += "/" + this.factMap.size;
            return u;
        }

        prettify(input) {
            var stuff = input.replace(/{.*}/g,"");
            say(stuff);
            return stuff;
        }

        checkGuess(promptCategory, targetCategory, guess) {
            say(adaptRegexp(this.factMap.get(targetCategory)));
            var regex1 = new RegExp(adaptRegexp(this.factMap.get(targetCategory)));
            
            if (regex1.test(guess)) {
                say("guess " + guess + " for " + targetCategory + " of " + promptCategory + " " + this.factMap.get(promptCategory) + " is right! Desired answer was " + this.factMap.get(targetCategory) );
                return true;
            } else {
                say("guess " + guess + " for " + targetCategory + " of " + promptCategory + " " + this.factMap.get(promptCategory) + " is WRONG! Desired answer was " + this.factMap.get(targetCategory) );
                return false;
            }
        }
    }

    function loadQuestionsFromTextBlob(blob, qStack){
        var numColMap = new Map();
        for (var line of blob.split('\n') ) {
            var numCol = line.split(':').length;
            if (numCol > 1) {
                numColMap.set(numCol, (numColMap.get(numCol) || 0) + 1);
            }
        }
        if (numColMap.size > 1) {
            say("ERROR : text blob has an irregular number of columns");
            for (var key of numColMap.keys() ) {
                say(key + " " + numColMap.get(key));
            }
            return;
        }
        var lineCount = 0;
        var headerArray = new Array();
        for (var line of blob.split('\n') ) {
            var cellArray = line.split(':');
            if (lineCount == 1) {  // we are in the header by definition // this is a big chapuza, I should try to get rid of the first and last lines which are blank
                headerArray = cellArray;
            } else if (cellArray.length > 1) {
                var factMap = new Map();
                var columnIndex = 0;
                for (var cell of cellArray) {
                    // say( headerArray[columnIndex] + " ==> " + cell);
                    factMap.set(headerArray[columnIndex], cell);
                    columnIndex++;
                }
                qStack.push(new QuestionCloud(line, factMap));

            }
            lineCount++;
        }
        return;
    }

    window.onload = function() {
        var progressReadout = document.getElementById('progressReadout');
        var questionText = document.getElementById('questionText');
        var answerBox = document.getElementById('answerBox');
        var tryButton = document.getElementById('tryButton');
        var tryResult = document.getElementById('tryResult');
        var outcomeTable = document.getElementById('outcomeTable');

        var numTry = 0;
        var questionMapIndex = -1;
        var promptCat = "integrand";
        //var targetCat = "term";
        var targetCat = "integral";
        var qStack = new Array();
        var outcomeMap = new Map();
        var quizTitle = promptCat + " ==> " + targetCat;
        loadQuestionsFromTextBlob(default_question_list,qStack);

        tryButton.addEventListener('click', checkAnswer);
        answerBox.addEventListener('keyup', function(event) { if(event.keyCode === 13) checkAnswer(); });

        function nextQuestion() {
            numTry=0;
            questionMapIndex++;
            if (questionMapIndex >= qStack.length) {
                progressReadout.innerText = quizTitle + ' Done';
                questionMapIndex = 0;
                questionText.innerText="";
                answerBox.value = "";
                tryButton.value = "repeat quiz";
                tryResult.innerText = "";
                buildOutcomeTable(outcomeMap,qStack,outcomeTable);
            } else {
                progressReadout.innerText = quizTitle + ' [' + questionMapIndex.toString() + '/' + qStack.length.toString() + ']'; 
                i = 1;
                nextKey = qStack[questionMapIndex].factMap.get(promptCat);
                questionText.innerText = nextKey;
                answerBox.value = "";
                tryButton.value = "try";
                tryResult.innerText = "";
            }
        }

        function buildOutcomeTable(m,q,t) {
            for (var key of m.keys()) {
                var row = t.insertRow(-1);
                var cell1 = row.insertCell(0);
                var cell2 = row.insertCell(1);
                var cell3 = row.insertCell(2);
                cell1.innerHTML = key;
                cell2.innerHTML = "";  
                cell3.innerHTML = m.get(key); 
            }

            for (var element of q) {
                element.prettify(element.questionId);
            }

            console.dir(q);
            console.dir(m);
        }

        function destroyOutcomeTable(t) {
            while(t.hasChildNodes()) { t.removeChild(t.firstChild); }
        }

        function updateOutcomeMap(m,k,n) {
            if (m.has(k)) {
                m.set(k,outcomeMap.get(k) + n);
            } else {
                m.set(k, n);
            }
        }

        function checkAnswer() {
            numTry++;
            if ( tryButton.value === 'repeat quiz' ) {
                destroyOutcomeTable(outcomeTable);
                tryButton.value = "next question";
            }
            else if ( questionText.innerText === '' || tryButton.value === 'next question') {
                nextQuestion();
            } else {
                if (qStack[questionMapIndex].checkGuess(promptCat,targetCat,answerBox.value)){
                    tryResult.innerText = "Right!";
                    tryButton.value = "next question";
                    updateOutcomeMap(outcomeMap,qStack[questionMapIndex].getUniquifier(promptCat,targetCat),numTry);
                } else {
                    if (numTry < 3) {
                        tryResult.innerText = "What?";
                        tryButton.value = tryButton.value + ".";
                    }
                    else {
                        tryResult.innerText =  qStack[questionMapIndex].factMap.get(targetCat);
                        tryButton.value = "next question";
                        updateOutcomeMap(outcomeMap,qStack[questionMapIndex].getUniquifier(promptCat,targetCat),numTry);
                    }
                }
            }
        }
    }
  </script>

  <style>
        html {
            font-family: Helvetica, Arial, sans-serif;
            font-size: 100%;
            color: #333; 
            background: #333;
        }
    
        #page-wrapper {
            width: 600px;
            background: #FFF;
            padding: 1em;
            margin: 1em auto;
            min-height: 300px;
            border-top: 5px solid #69c773;
            box-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
    
        h1 {
            font-size: 220%;
            margin-top: 0;
        }

        h2 {
            font-size: 220%;
            margin-top: 5;
        }

        #tryButton {
            background-color:#69c773;
            color: white;
            border: none;
            padding: 15px 64px;
        }

      </style>
</head>

<body>
  <div id="page-wrapper">
    <h1>Quiz</h1>
    <div>
        <p id="progressReadout">[1/]</p> 
        <h2 id="questionText"></h2>
        <input type="text" id="answerBox" value="" autofocus>
        <input type="button" id="tryButton" value="start">
        <h2 id="tryResult"></h2> 
    </div>
    <div>
        <table id="outcomeTable"></table>
    </div>
  </div>
</body>

</html><!-- """ # -->

